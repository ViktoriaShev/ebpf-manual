![[Снимок экрана от 2025-05-15 11-03-48.png]]

## Программа can_bus.c
###  Основные функции кода:
### `void frame_process(struct can_frame* frame, port_address* setTty, int* count)`

Обрабатывает один CAN-фрейм и перенаправляет его в соответствующий tty.
#### Шаги:

1. **Рассчитывает `short_id`**:
Этот код — это **утилита, принимающая CAN-сообщения (Controller Area Network)** с интерфейса `can0`, и **перенаправляющая данные из этих сообщений в соответствующие последовательные порты `/dev/ttyS<N>`** (ttyS11–ttyS18), в зависимости от CAN ID.

Вот что делает программа, по шагам:

---

### `createCanSocket(const char* interface)`

Создаёт и настраивает RAW-сокет для интерфейса CAN (например, `can0`).

- Использует `socket(PF_CAN, SOCK_RAW, CAN_RAW)` — создаёт CAN сокет.
- `ioctl(SIOCGIFINDEX)` — получает индекс интерфейса `can0`.
- `bind()` — привязывает сокет к интерфейсу.
- Возвращает файловый дескриптор сокета или `-1` в случае ошибки.

---

### `open_port(int n)`

Открывает и настраивает последовательный порт `/dev/ttyS<n>`.  
Устанавливается:

- 9600 бод, 8 бит, без чётности, 1 стоп-бит (9600 8N1).
- Без аппаратного/программного управления потоком.
- Используется `cfmakeraw()` для отключения обработки данных терминалом.
- Возвращает `fd` (файловый дескриптор), либо `-1`, если неудачно.

---

### `frame_process(struct can_frame* frame, port_address* setTty, int* count)`

Обрабатывает одно CAN-сообщение:

1. Проверяет, попадает ли CAN ID в диапазон `0x701`–`0x708`.
2. Вычисляет `short_id = can_id - 0x700`, который будет соответствовать порту `ttyS<11..18>`.
3. Если порт уже открыт — данные пишутся в соответствующий `fd`.
4. Если порт не открыт:
    
    - Открывает `ttyS<N>`, соответствующий short_id.
    - Добавляет его в массив `setTty`.
    - Записывает туда данные.

---

### `main()`

1. Инициализирует CAN-сокет через `createCanSocket("can0")`
2. Инициализирует массив `port_address setTty[MAX_PKT]`:
    - Используется для хранения связки `{CAN short ID ↔ файловый дескриптор tty}`.
3. Цикл  бесконечно:    
    - Считывает `can_frame` из сокета.
    ```c
        int nbytes = read(sock, &frame, sizeof(frame));
	```
    - В рамках заданного диапазона `0x701`–`0x708`:
		- вызывает `frame_process()`
		- ограничивает число одновременно открытых tty-портов до `MAX_PKT` (8)
4. После выхода из цикла:
    - Закрывает CAN-сокет и все открытые tty-порты.


## Программа ports.sh:

— Создаётся пара связанных псевдотерминалов (`PTY`):

- Первый `PTY` будет смонтирован как `/dev/ttyS${base}` (например, `/dev/ttyS11`)
- Второй `PTY` как `/dev/ttyS$((base+1))` (например, `/dev/ttyS12`)
- Опции:
    - `raw` — режим без обработки символов (как в обычном UART)
    - `echo=0` — отключение эхо-вывода (чтобы не дублировались символы)

Создаёт **4 пары** виртуальных последовательных портов:

- `/dev/ttyS11` <--> `/dev/ttyS12`
- `/dev/ttyS13` <--> `/dev/ttyS14`
- `/dev/ttyS15` <--> `/dev/ttyS16`
- `/dev/ttyS17` <--> `/dev/ttyS18`

Любая программа, которая пишет в `/dev/ttyS11`, будет "видна" на чтение в `/dev/ttyS12`, и наоборот. То же для остальных пар.