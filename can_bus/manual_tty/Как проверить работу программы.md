Первым делом выполнением файл ports.sh:
```bash
./poprts.sh
```
Компилируем программу:
```bash
gcc -o can_bus can_bus.c
```
и запускаем ее.
Параллельно следует в новом терминале выполнить следующую команду:
```bash
dd if=/dev/ttyS13 bs=1 count=8 | hexdump -C
```
- `if=/dev/ttyS13` — чтение с порта
- `bs=1` — размер блока 1 байт
- `count=8` — считать ровно 8 байт
- после этого `dd` завершает работу, передаёт 8 байт в `hexdump`, и тот их отображает

**То есть `dd` явно знает, когда закончить читать, в отличие от `cat`, который работает бесконечно.**
#### 1. **Буферизация и поведение `dd`**

- Команда `dd` с `count=8` читает **ровно 8 байт**, и **только тогда завершает работу**.
- Пока 8 байт **не поступили на порт полностью**, `dd` ждёт и **ничего не выводит**.
- После получения 8 байт `dd` закрывает поток, и только тогда `hexdump` получает вход и отображает результат.

#### 2. **Режимы работы порта `/dev/ttyS13`**

Порт может быть в **"canonical" (линейном)** или **"raw"** режиме:

- **Raw mode** ( `cfmakeraw()`):
    
    - Данные читаются байт за байтом, **без обработки**.
    - Однако это не отменяет буферизацию **внутри ядра** или драйвера, особенно если `VMIN` и `VTIME` настроены.
    
То есть только после ручного завершения данной команды будет выведены данные, что все это время записывались в ttyS