# Kernel программа и userspace программа 

Концептуальная разница между eBPF и user space

|                                                                  |                                                                         |
| ---------------------------------------------------------------- | ----------------------------------------------------------------------- |
| **eBPF программа (Kernel space)**                                | **User space** **программа** **(User space)**                           |
| Загружается и исполняется в **ядре** Linux                       | Работает в обычном пользовательском окружении (например, Python, C, Go) |
| Написана на "почти-С" языке                                      | Написана на Python, Go, C, Rust и т.д.                                  |
| Очень ограниченная среда исполнения                              | Полный доступ к файловой системе, сети, UI и т.д.                       |
| Не может делать системные вызовы                                 | Может делать что угодно (в пределах прав)                               |
| Использует BPF **helpers**                                       | Использует BPF API для взаимодействия с ядром                           |
| Пример: ловит события в ядре, считает пакеты, фильтрует syscalls | Пример: загружает eBPF-программу, читает результаты из eBPF map         |

**Что делает eBPF-программа?**

**Она:**

- Живёт **внутри ядра**
- "Вешается" на событие (например, системный вызов execve, сетевой пакет, tracepoint)
- Очень быстро исполняется (JIT-компиляция)
- Имеет **ограниченный набор команд** и **ограниченное время выполнения**
- Может обращаться к:

- helper-функциям (bpf_trace_printk, bpf_map_lookup_elem, bpf_redirect)
- BPF maps (для хранения и передачи данных)

- Не может:

- Выделять память динамически
- Делать системные вызовы
- Работать в фоновом режиме без события

**Что делает userspace программа?**

**Она:**

- Пишется на обычном языке (Python, Go, C и др.)
- Загружает eBPF-программу в ядро через **libbpf**, **BCC**, **bpftool**, **bpfd**
- Может:

- Чтение и запись eBPF maps (через API)
- Прослушка событий (perf буферы, trace_pipe, ringbuf)
- Визуализация/анализ данных
- Управление жизненным циклом eBPF-программы (загрузка/выгрузка)
![[Pasted image 20250415181705.png]]
#  **ELF-файлы eBPF: структура и использование**

Формат ELF (Executable and Linkable Format) является стандартным для eBPF-программ и содержит скомпилированный байт-код вместе с метаданными, необходимыми для загрузки и верификации.

## **1. Ключевые секции в ELF-файлах eBPF**

| Секция          | Назначение |
|-----------------|------------|
| `.text`         | Содержит основной байт-код eBPF-программы |
| `.maps`         | Определяет конфигурации BPF-карт |
| `.license`      | Указывает лицензию программы (например, `GPL`) |
| `.rodata`       | Только для чтения данные (константы, строки) |
| `.BTF` (опц.)   | BPF Type Format для CO-RE (Compile Once, Run Everywhere) |
| `.symtab` / `.strtab` | Таблицы символов (отладочная информация) |

---

## **2. Как создаются ELF-файлы eBPF**
### **Процесс компиляции**
1. **Исходный код (C) → Clang/LLVM → Объектный файл (.o)**
   ```sh
   clang -O2 -target bpf -c program.c -o program.o
   ```
2. **Опционально: генерация BTF (для CO-RE)**
   ```sh
   pahole -J program.o
   ```

### **Пример минимальной eBPF-программы**
```c
#include <linux/bpf.h>

SEC("xdp")
int xdp_drop(struct xdp_md *ctx) {
    return XDP_DROP;
}

char __license[] SEC("license") = "GPL";
```
- `SEC("xdp")` указывает загрузчику, куда прикрепить программу.
- `__license` обеспечивает совместимость с вспомогательными функциями.

---

## **3. Анализ ELF-файлов eBPF**
### **Использование `readelf`**
```sh
readelf -a program.o
```
- Показывает секции, символы и перемещения.

### **Использование `llvm-objdump`**
```sh
llvm-objdump -S program.o
```
- Декомпилирует байт-код eBPF.

### **Использование `bpftool`**
```sh
bpftool prog load program.o /sys/fs/bpf/program
bpftool prog show
```
- Загружает и анализирует eBPF-программы.

---

## **4. Ключевые особенности ELF для eBPF**
### **Перемещения (поддержка CO-RE)**
- Позволяет программам работать на разных версиях ядра.
- Использует секции `.BTF` и `.rel` для корректировки типов.

### **Определения карт**
- Карты объявляются в секции `.maps`:
  ```c
  struct {
      __uint(type, BPF_MAP_TYPE_HASH);
      __uint(max_entries, 1024);
      __type(key, u32);
      __type(value, u64);
  } my_map SEC(".maps");
  ```

### **Отладочная информация**
- Данные DWARF или BTF помогают в отладке:
  ```sh
  bpftool btf dump file program.o
  ```

---

## **5. Загрузка ELF-файлов eBPF**
### **Через `libbpf` (рекомендуется)**
```c
struct bpf_object *obj;
bpf_object__open_file("program.o", &obj);
bpf_object__load(obj);
```
- Управляет созданием карт, загрузкой программ и перемещениями.

### **Через `iproute2` (устаревший способ)**
```sh
tc filter add dev eth0 ingress bpf obj program.o sec classifier
```
- Старый метод, всё ещё используется для программ TC и XDP.

---

## **6. Итог**
- **ELF — стандартный формат** для eBPF-программ.
- **Секции, такие как `.text`, `.maps` и `.license`**, определяют поведение программы.
- **BTF обеспечивает CO-RE** для совместимости между разными версиями ядра.
- **Инструменты `bpftool` и `llvm-objdump`** помогают анализировать ELF-файлы.

Для более подробной информации см. [документацию BPF в ядре](https://www.kernel.org/doc/html/latest/bpf/index.html).

# Loader и Verification Architecture
![[Pasted image 20250414165234.png]]
Верификатор eBPF — это критически важный компонент, обеспечивающий **безопасность выполнения** eBPF-программ в ядре Linux. Он анализирует код перед загрузкой, предотвращая потенциально опасные операции.

## **1. Основные задачи верификатора**

- **Гарантирует безопасность**: Программа не может повредить ядро.
- **Проверяет корректность**: Все инструкции выполняются без ошибок.
- **Ограничивает сложность**: Программа должна завершаться за конечное время.
- **Контролирует доступ**: Проверяет допустимость операций с памятью и вызовов.

---

## **2. Как работает верификатор**

### **2.1. Анализ всех возможных путей выполнения**

Верификатор **не выполняет программу**, а **симулирует** её работу, учитывая:

- **Все возможные ветвления** (if/else, циклы).
- **Состояние регистров** (типы данных, диапазоны значений).
- **Доступ к памяти** (проверка границ, корректность указателей).
### **2.2. Проверка регистров**

Каждый регистр eBPF-виртуальной машины отслеживается с помощью структуры `bpf_reg_state`, которая содержит:

- **Тип значения**:
    
    - `NOT_INIT` — регистр не инициализирован.
    - `SCALAR_VALUE` — обычное число (не указатель).
    - `PTR_TO_*` — указатель (на контекст, пакет, map и т. д.).
- **Диапазон возможных значений** (для предотвращения переполнений).
### **2.3. Ограничение сложности**

- **Максимум 1 млн инструкций** (для непривилегированных программ — 4096).
- **Глубина стека вызовов** ограничена.
- **Запрещены бесконечные циклы** (кроме циклов с гарантированным условием выхода).

---

## **3. Примеры ошибок верификации**

### **3.1. Доступ к неинициализированной памяти**

c
```
u32 x;  // Не инициализирована
bpf_printk("%d", x);  // Ошибка: чтение неинициализированного значения
```
**Решение**: Все переменные должны быть явно проинициализированы.

### **3.2. Выход за границы массива**

c
```

u32 arr[10];
u32 x = arr[20];  // Ошибка: выход за границы
```
**Решение**: Верификатор проверяет индексы на этапе компиляции.

### **3.3. Непроверенные указатели**

c
```
u64 *value = map.lookup(&key);
*value = 42;  // Ошибка: value может быть NULL
```
**Решение**: Добавить проверку.
### **3.4. Недопустимые вызовы helper-функций**

c
```

// Вызов bpf_get_current_pid_tgid() в XDP-программе
SEC("xdp")
int xdp_prog(void *ctx) {
    u64 pid = bpf_get_current_pid_tgid();  // Ошибка: недоступно для XDP
    return XDP_PASS;
}
```

**Решение**: Использовать только разрешённые для типа программы helper-функции.

---

## **4. Верификатор в действии**

### **4.1. Логи верификации**

При ошибке верификатор выдаёт подробный лог:

plaintext

```
processed 61 insns (limit 1000000) max_states_per_insn 0 total_states 4 peak_states 4 mark_read 3
```

- **processed 61 insns**: Программа содержит 61 инструкцию.
- **limit 1000000**: Максимально допустимое число инструкций.
- **total_states 4**: Всего состояний регистров было сохранено.
- **peak_states 4**: Пиковое число состояний.

Пример лога для ошибки:

plaintext
```

16: (85) call bpf_get_current_pid_tgid#14
unknown func bpf_get_current_pid_tgid#14
```

### **4.2. Визуализация потока выполнения**

Можно создать граф потока управления с помощью `bpftool`:

bash
```
bpftool prog dump xlated name kprobe_exec visual > out.dot
dot -Tpng out.dot > out.png
```

Результат — изображение с **блоками кода** и **условными переходами**.

---

## **5. Оптимизации верификатора**

### **5.1. State Pruning (отсечение состояний)**

Если верификатор встречает **одинаковое состояние регистров** в одной точке программы, он пропускает повторный анализ. Это ускоряет проверку сложных программ.

### **5.2. Проверка helper-функций**

Каждый вызов вспомогательной функции проверяется на:

- **Доступность** для типа программы.
- **Корректность аргументов** (типы, допустимые значения).

# Map

BPF maps — это **механизм хранения данных в виде ключ-значение**, который позволяет обмениваться данными между:
- **eBPF-программами** (в пространстве ядра)
- **Пользовательскими приложениями** (в пространстве пользователя)
    
Это одна из самых мощных возможностей eBPF, позволяющая:
- Сохранять состояние (**stateful processing**)
- Передавать настройки из пользовательского пространства
- Организовывать **реальное взаимодействие** между ядром и пользовательскими программами

## **1. Основные характеристики BPF Maps**

### **1.1. Типы BPF Maps**

Linux поддерживает разные типы map, каждый из которых оптимизирован под конкретные задачи:

|**Тип Map**|**Описание**|**Пример использования**|
|---|---|---|
|**Хеш-таблица (`BPF_MAP_TYPE_HASH`)**|Классическое хранилище ключ-значение|Подсчёт событий, хранение метаданных|
|**Массив (`BPF_MAP_TYPE_ARRAY`)**|Массив фиксированного размера (индекс = ключ)|Быстрый поиск, хранение настроек|
|**Per-CPU хеш (`BPF_MAP_TYPE_PERCPU_HASH`)**|Отдельная хеш-таблица для каждого CPU|Высокочастотные обновления (без блокировок)|
|**Per-CPU массив (`BPF_MAP_TYPE_PERCPU_ARRAY`)**|Отдельный массив для каждого CPU|Низколатентные счётчики|
|**LRU-хеш (`BPF_MAP_TYPE_LRU_HASH`)**|Автоматически удаляет редко используемые данные|Кэширование, ограничение скорости|
|**Кольцевой буфер (`BPF_MAP_TYPE_RINGBUF`)**|FIFO-буфер (один производитель, один потребитель)|Высокопроизводительная передача событий|
|**Трассировка стека (`BPF_MAP_TYPE_STACK_TRACE`)**|Хранит стек вызовов ядра|Профилирование, отладка|
|**Longest Prefix Match (LPM)**|Поиск по префиксу (дерево)|Маршрутизация IP, правила фаервола|
|**SockMap / DevMap**|Хранит ссылки на сокеты/устройства|Перенаправление сетевых пакетов (`XDP`)|
|**Массив программ (`BPF_MAP_TYPE_PROG_ARRAY`)**|Хранит ссылки на eBPF-программы|Tail calls (переход между программами)|
|**Map-of-Maps (`BPF_MAP_TYPE_HASH_OF_MAPS`)**|Вложенные map|Динамическое управление политиками|

---

### **1.2. Основные сценарии использования**

- **Передача настроек** (userspace → ядро)
    - Пример: правила фильтрации, частота семплирования.
    
- **Сохранение состояния** (ядро → ядро)
    - Пример: счётчики, ограничители скорости.
        
- **Передача событий** (ядро → userspace)
    - Пример: `perf_buffer` для мониторинга в реальном времени.
        
- **Обмен данными между программами**
    - Пример: одна eBPF-программа обновляет map, другая читает.
        
---

## **2. Работа с BPF Maps**

### **2.1. Создание Map**

#### **Из пользовательского пространства (C/libbpf)**

c
```

struct {
    __uint(type, BPF_MAP_TYPE_HASH);
    __uint(max_entries, 1024);
    __type(key, u32);
    __type(value, u64);
} counter_table SEC(".maps");

- `type`: Тип map (например, `BPF_MAP_TYPE_HASH`).
    
- `max_entries`: Максимальное количество элементов.
    
- `key` / `value`: Типы данных.
    
```

### **2.2. Доступ к Map**

#### **Из eBPF (в ядре)**

c

```

u32 key = 123;
u64 *value = counter_table.lookup(&key);
if (value) {
    (*value)++;  // Увеличиваем счётчик
    counter_table.update(&key, value);
}
```

- `lookup()`: Получить значение (возвращает `NULL`, если не найдено).
    
- `update()`: Добавить/обновить значение.
    
- `delete()`: Удалить ключ.
    
### **Из пользовательского пространства (BCC)**
```

#define BPF_MAP_PATH "/sys/fs/bpf/filter_map"

```

Путь к BPF-карте, созданной XDP-программой и закрепленной (pinned) в файловой системе.

- Определение структуры для ключа карты

  Ключ (key) eBPF-карты состоит из: 
  **be32 ip — IP-адрес (4 байта, big-endian). \
   **be16 port — Порт (2 байта, big-endian).

- Функция добавления записи в карту

  Функция bpf_obj_get() используется для открытия eBPF-карты (или другого eBPF-объекта), который был закреплен (pinned) в файловой системе BPF.

  Прототип функции

```

int bpf_obj_get(const char *pathname);

```

Аргумент:

pathname — путь к eBPF-объекту в файловой системе BPF (/sys/fs/bpf/...).\

Если успешно, возвращает файловый дескриптор (FD) eBPF-объекта (неотрицательное число)

---

Для более детального изучения см. [документацию ядра](https://docs.kernel.org/bpf/maps.html).