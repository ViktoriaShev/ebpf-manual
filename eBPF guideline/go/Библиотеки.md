## Gobpf

`Gobpf` [https://github.com/iovisor/gobpf](https://github.com/iovisor/gobpf)
Возможно, первой серьезной реализацией Golang был проект gobpf, который находится рядом с BCC как часть Iovisor. Однако он уже некоторое время не поддерживается активно, и пока я это пишу, идут обсуждения его отмены, 
`gobpf` ([https://github.com/iovisor/gobpf](https://github.com/iovisor/gobpf)официально **не поддерживается активно** уже несколько лет.

### Статус на 2025:

- **Последние коммиты**: очень редкие, в основном багфиксы или минимальные изменения.
- **README**: в нём прямо указано, что проект **не развивается активно**, и предлагается искать альтернативы.
- **Совместимость**: `gobpf` не поддерживает современные eBPF-фичи, такие как CO-RE (Compile Once – Run Everywhere), и плохо интегрируется с новой архитектурой BPF-программ.

## EBPF-GO

Это **одна из самых популярных Go-библиотек для работы с eBPF**, разработанная Cilium. Она предоставляет безопасный, нативный доступ к eBPF API, включая:

- Загрузку программ и карт
- Управление pinned maps/programs в BPF FS
- Выполнение `bpf()`-системных вызовов через Go-интерфейс

Она также предоставляет удобные функции для управления и загрузки программ и карт eBPF, включая поддержку CO-RE, все реализовано исключительно на Go. 
С этой библиотекой у вас есть возможность компилировать программы eBPF в байт-код и встраивать этот байт-код в исходный код Go, используя предоставленный инструмент под названием bpf2go. Вам понадобится компилятор LLVM/Clang для выполнения этой генерации в рамках этапа сборки. После компиляции кода Go у вас есть один двоичный файл Go, который вы можете распространять, который включает байт-код eBPF и является переносимым на разные ядра, без каких-либо зависимостей, кроме самого ядра Linux. Библиотека cilium/ebpf также поддерживает загрузку и управление программами eBPF, созданными как автономные файлы ELF (например, примеры *.bpf.o, которые вы видели в этой книге). На момент написания этой статьи библиотека cilium/ebpf поддерживает события perf для трассировки, включая относительно недавние события fentry, а также обширный набор типов сетевых программ, таких как XDP и вложения сокетов cgroup. В каталоге примеров этого проекта в cilium/ebpf вы увидите, что код C для программ ядра находится в тех же каталогах, что и соответствующий код пользовательского пространства в Go: • Файлы C начинаются с // +build ignore, что сообщает компилятору Go игнорировать их. На момент написания этой статьи выполняется обновление для изменения на более новый стиль //go:build тега сборки. • Файлы пользовательского пространства включают строку, подобную следующей, которая сообщает компилятору Go о необходимости вызова инструмента bpf2go для C-файла(ов): //go:generate go run github.com/cilium/ebpf/cmd/bpf2go -cc $BPF_CLANG -cflags $BPF_CFLAGS bpf <C filename> -- -I../headers C и Libbpf | 193 Запуск go:generate для пакета перестраивает программу eBPF и регенерирует скелет за один шаг. Подобно bpftool gen skeleton, который вы видели в Главе 5, bpf2go генерирует скелетный код для манипулирования объектами eBPF, минимизируя код пользовательского пространства, который вам нужно написать самостоятельно (за исключением того, что он генерирует код Go, а не C). Выходные файлы также включают файлы объектов .o, содержащие байт-код. Фактически, bpf2go генерирует две версии файлов байт-кода .o для архитектур big- и littleendian. Также есть два соответственно сгенерированных файла .go, и правильные версии для целевой платформы используются во время компиляции. Например, автоматически сгенерированные файлы в примере kprobe из cilium/ebpf: • Файлы bpf_bpfeb.o и bpf_bpfel.o ELF, содержащие байт-код eBPF • Файлы bpf_bpfeb.go и bpf_bpfel.go, которые определяют структуры и функции Go

## Libbpfgo

С помощью этой библиотеки есть возможность скомпилировать программы eBPF в байт-код и встроить этот байт-код в исходный код Go, используя прилагаемый инструмент под названием bpf2go. Для этого понадобится компилятор LLVM/Clang, чтобы выполнить эту генерацию на этапе сборки. 

---

###   Что такое **libbpfgo**

**`libbpfgo`** — это **Go-обёртка** над низкоуровневой `libbpf` (C-библиотекой из ядра Linux), разработанная **командой Aqua Security**. Она предоставляет **Go-разработчикам удобный и "нативный" интерфейс** для загрузки, управления и взаимодействия с eBPF-программами.

---

###  Основные возможности

- Загрузка eBPF-программы из `.o` файла (`.bpf.o`)
- Получение доступа к eBPF-картам
- Управление ring/perf buffers с **каналами Go**
- Поддержка **CO-RE (Compile Once – Run Everywhere)**: программа адаптируется к структурам ядра во время исполнения
- Обработка событий из ядра асинхронно через **Go-каналы**

---

### Пример использования (из `README`):

```go
bpfModule := bpf.NewModuleFromFile(bpfObjectPath)
bpfModule.BPFLoadObject()

mymap, _ := bpfModule.GetMap("mymap")
mymap.Update(key, value)

rb, _ := bpfModule.InitRingBuffer("events", eventsChannel, bufferSize)
rb.Start()

e := <-eventsChannel
```

#### Что происходит:

1. **Чтение** eBPF-объектного файла
2. **Загрузка** байткода в ядро
3. **Манипуляция** с eBPF-картой (map)
4. **Инициализация ring buffer** для получения событий
5. **Асинхронное получение события** через канал

---

####  Архитектура

- Написана на Go
- Использует **CGO** для вызова `libbpf` C-функций
- Близка по подходу к `bcc`, но не требует Python
- Предоставляет **высокоуровневые абстракции** для большинства типичных задач (загрузка, мапы, события, tracepoints и т.п.)
    

---

#### Особенности и предостережения

- Использует **CGO**, что:
    
    - Может влиять на **производительность**
        
    - Усложняет **кросс-компиляцию**
        
    - Вносит дополнительную зависимость от C-окружения (`libbpf`, `libelf`, `zlib`, `clang`, и др.)
    

---
## Что такое `bpf2go`

Это утилита для:

- Компиляции `.c` или `.bpf.c` файлов с помощью `clang`
- Генерации `.go` файла с типами и интерфейсом для доступа к eBPF-картам и программам
- Полной интеграции eBPF в Go-приложение без необходимости вручную оперировать `*ebpf.Program` или `*ebpf.Map`

---

### Установка

Если уже установлен Go и `github.com/cilium/ebpf`, то `bpf2go` можно использовать так:
```bash

`go install github.com/cilium/ebpf/cmd/bpf2go@latest`
```
Он установится как бинарь `~/go/bin/bpf2go`.

---

### Пример структуры проекта


```

project
├── main.go 
├── filter.bpf.c 
├── filter.bpf.h (если нужно)
└── go.mod
```
---

### Как использовать `bpf2go`

```
bpf2go -cc clang -cflags "-O2 -g -Wall" Filter filter.bpf.c -- -I./headers
```
### Расшифровка:

- `Filter` — это префикс, к которому будет добавлено `_ebpf.go` и `_ebpf.o`
- `filter.bpf.c` — исходный файл с eBPF-программой
- `-- -I./headers` — путь к заголовочным файлам, если они нужны

---

##  Что будет сгенерировано?

Появятся файлы:

```
filter_bpfeb.o       ← eBPF-объект для little endian 
filter_bpfel.o       ← eBPF-объект для big endian 
filter_bpfeb.go      ← Go-обёртка с типами, картами и функциями загрузки`
```
---

### Использование в `main.go`

```go
package main 
import (     
	"log"     
	"github.com/cilium/ebpf" 
) 

func main() {     
	spec, err := LoadFilter()     
	if err != nil {         
	log.Fatalf("load spec: %v", err)     
	}      
	objs := FilterObjects{}     
	if err := spec.LoadAndAssign(&objs, nil); err != nil {   
	     log.Fatalf("load and assign: %v", err)     
	}      
	defer objs.Close()      // Пример доступа к карте   
	key := uint32(1234)     
	value := uint32(1)     
	if err := objs.FilterMap.Put(key, value); err != nil {   
	      log.Fatalf("put: %v", err)     
	}      
	log.Println("Success") 
}
```

---