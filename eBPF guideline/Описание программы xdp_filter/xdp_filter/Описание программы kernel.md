Ниже приведено объяснение ключевых особенностей кода eBPF-программы для XDP (eXpress Data Path), которая фильтрует пакеты на основе IP-адреса и порта.

- Заголовок лицензии

/_ SPDX-License-Identifier: (LGPL-2.1 OR BSD-2-Clause) _/ 

Указывает, что код лицензируется под LGPL-2.1 или BSD-2-Clause.\
Позволяет использовать этот код в проектах с разными типами лицензий.

- Отключение глобальных данных

```

#define BPF_NO_GLOBAL_DATA

```

Запрещает использование глобальных переменных в eBPF-коде.\
Это ограничение связано с eBPF-архитектурой: глобальные данные не поддерживаются в XDP-программах.

- Подключение заголовочных файлов

```
#include <linux/bpf.h> // Основные eBPF API \
#include <bpf/bpf_helpers.h> // Вспомогательные макросы и функции
```

- Определение структур

Для реализации поставленной задачи была определена структура "filter, которая оределяет тип для ip и post. Для таких сетевых параметров обычно используется big-endian 32/16 bits тип хранения.

Map — это структура данных, к которой можно получить доступ из программы eBPF и из пространства пользователя. Карты можно использовать для обмена данными между несколькими программами eBPF или для связи между приложением пространства пользователя и кодом eBPF, работающим в ядре.

Инициализируем eBPF map "filter_map", которая будет хранить в key структуру filter с данными ip и port. Тип данной map - BPF_MAP_TYPE_HASH.\

Карты на основе BTF должны быть размещены в разделе(SEC) ".maps".

```

struct {

    __uint(type, BPF_MAP_TYPE_HASH);   // Тип карты: хэш-таблица

    __uint(max_entries, 1024);         // Максимальное количество записей

    __type(key, struct filter);        // Ключ — структура filter (IP + порт)

    __type(value, int);                // Значение — просто число (обычно 1)

} filter_map SEC(".maps");

  

```

- Объявление xdp программы

```

SEC("xdp")

int filter_packets(struct xdp_md *ctx) {

```

SEC("xdp") — макрос, объявляющий XDP-программу.

Название раздела часто имеет неявное значение и может изменить то, как загрузчик (библиотека), такой как libbpf, будет интерпретировать содержимое этого раздела.

Все программы в разделе xdp будут загружены как программы типа BPF_PROG_TYPE_XDP и присоединенного типа BPF_XDP, в xdp.frags также будет установлен флаг BPF_F_XDP_HAS_FRAGS.

Программа XDP вызывается ядром с контекстом xdp_md. Возвращаемое значение указывает, какое действие ядро ​​должно выполнить с пакетом, разрешены следующие значения:

- XDP_DROP — отбрасывает пакет. Следует отметить, что поскольку мы отбрасываем пакет очень рано, он будет невидим для таких инструментов, как tcpdump.
- XDP_PASS — передает пакет в сетевой стек. Пакетом можно манипулировать заранее
- 
struct xdp_md \*ctx — структура, содержащая данные о сетевом пакете.

Обычно структура выглядит примерно так:

```

struct xdp_md {

    __aligned_u64 data;         // Указатель на начало данных пакета

    __aligned_u64 data_end;     // Указатель на конец данных пакета

    __aligned_u64 data_meta;    // Дополнительный указатель для метаданных

    __u32 rx_queue_index;       // Индекс очереди для XDP

};

  

```

- Получение указателей на данные пакета  

```

void *data = (void *)(long)ctx->data;

void *data_end = (void *)(long)ctx->data_end;

```

ctx->data — начало пакета.
ctx->data_end — конец пакета.

Нельзя обращаться к памяти за data_end (иначе программа завершится с ошибкой).
Проверяем, что он полностью помещается в пакете (если нет — пропускаем пакет).

- Обработка Ethernet-заголовка

Cтруктура ethhdr состоит из 14 байт:

```

struct ethhdr *eth = data;

  

if ((void *)(eth + 1) > data_end) return XDP_PASS;

struct ethhdr *eth = data; //Мы начинаем обработку с Ethernet-заголовка.

```

Эта строка проверяет, является ли протокол Ethernet IP. 
ETH_P_IP — это значение, которое соответствует протоколу IP. 
Если протокол не IP, то пакет пропускается с помощью XDP_PASS.

```

if (eth->h_proto != __constant_htons(ETH_P_IP)) return XDP_PASS;

```

- Обработка IP-заголовка:
```

struct iphdr *ip = (void *)(eth + 1);

```

После Ethernet-заголовка начинается IP-заголовок. Мы вычисляем его адрес, прибавив размер Ethernet-заголовка (это eth + 1).

- Создание ключа (IP + порт)

```

struct filter key = {};

key.ip = ip->saddr;

```

Заполняем структуру key — записываем IP-адрес отправителя.

- Определение порта (TCP или ICMP)  

Если TCP → извлекаем порт назначения (tcp->dest).
Если ICMP → устанавливаем key.port = 0 (ICMP не использует порты).
Все остальные протоколы пропускаем (XDP_PASS).

- Проверка, нужно ли блокировать пакет

```

int *value = bpf_map_lookup_elem(&filter_map, &key);

bpf_printk("%d\n", value);

if (value != NULL) {

    bpf_printk("Blocked packet: dest_ip=%x, dest_port=%d\n", key.ip, key.port);

    return XDP_DROP;

}

```

bpf_map_lookup_elem(&filter_map, &key) ищет key (IP + порт) в filter_map.

```

static void *(* const bpf_map_lookup_elem)(void *map, const void *key) = (void *) 1;

```

Аргумент карты должен быть указателем на определение карты, а ключ должен быть указателем на ключ, который вы хотите найти.
Возвращаемое значение будет указателем на значение карты или NULL. Значение является прямой ссылкой на память ядра, где хранится это значение карты, а не копией.

Если запись найдена → блокируем пакет (XDP_DROP).
Если нет → пропускаем (XDP_PASS).

- Указание лицензии  

```

char LICENSE[] SEC("license") = "Dual BSD/GPL";

```

eBPF-программы должны указывать лицензию. "Dual BSD/GPL" позволяет использовать код как с BSD, так и с GPL.
## Принцип работы программы

Если пакет соответствует правилам фильтрации (которые хранятся в eBPF-карте filter_map), он отбрасывается (XDP_DROP).
В остальных случаях — пропускается (XDP_PASS).

Материал был взят из [документации к eBPF](https://docs.ebpf.io/linux/)