Команда: 
```
sudo cat /sys/kernel/debug/tracing/trace_pipe: 
```

В консоли выводится следующий результат: 

![[Pasted image 20250415180232.png]]

Чтобы проверить работу программы нужно послать физически пакеты tcp в three hand shaking 
## Зачем эта программа:

1. Защита от атаки syn flood
Есть также протокол транспортного уровня оси SCTP

XDP-фильтр без ответа (RST) хорошо работает, когда: 
- Важна скорость, а не "вежливость", 
- Нужно игнорировать злоумышленников, не говоря им, что хост получатель существует (stealth mode), 
- Необходимо отбивать сканеры, которые ищут открытые порты
- Необходимо защищать внутренние сервисы, которые не должны быть видны снаружи.

## Примеры использования

1. Загрузка программы:
   ```bash
   sudo ./better_filter eth0 load
   ```

2. Добавление правила:
   ```bash
   sudo ./better_filter eth0 add 192.168.1.1 80
   ```

3. Просмотр статистики:
   ```bash
   sudo ./better_filter eth0 stats
   ```
Если ты блокируешь TCP SYN пакеты на уровне XDP (eXpress Data Path), а сетевой адаптер продолжает слать их, это вполне ожидаемое поведение в определённых условиях. Вот почему:

## Почему адаптер продолжает слать SYN?

1. **XDP работает после получения пакета от физического уровня**, но до стека ядра. Это значит, что пакет уже пришёл в систему, но ты его просто "отрезаешь" до того, как он достигнет TCP/IP-стека.
    
2. **Отправитель (например, клиент) не получает ответа**, потому что SYN дропается, и он считает, что пакет потерялся. В ответ он _повторно шлёт SYN_ по таймауту (в соответствии с TCP-стеком у отправителя).
    
3. **Сетевой адаптер сам по себе не решает, когда остановиться.** Он просто передаёт всё, что приходит по сети. Он не знает, что ты блокируешь SYN внутри ядра.

Атака SYN-пакетами называется **SYN flood (SYN-флудинг)**. Это одна из форм **атаки типа "отказ в обслуживании" (DoS)**, при которой злоумышленник пытается перегрузить систему, запрашивая большое количество полуподключений, чтобы исчерпать ресурсы сервера.

### Как работает SYN flood:

1. Клиент отправляет SYN-пакет серверу, инициируя соединение по протоколу TCP.
    
2. Сервер отвечает SYN-ACK и ожидает подтверждение (ACK) от клиента.
    
3. В нормальной ситуации клиент присылает ACK, и соединение устанавливается.
    
4. При SYN flood злоумышленник **никогда не отправляет ACK**, оставляя соединение "висящим".
    
5. Сервер держит это полуподключение в очереди, тратит ресурсы и, если таких запросов много — перестает обрабатывать легитимные соединения.

### История атаки SYN flood:

Эта атака впервые стала широко известной в **1996 году**. Один из первых и громких случаев произошел, когда **журнал Phrack** (популярное хакерское издание) опубликовал статью, описывающую уязвимость TCP и то, как можно использовать SYN flood для выведения сервера из строя. Вскоре после публикации были зафиксированы реальные атаки на серверы крупных компаний и университетов.

Один из примеров — атаки на **паназиатский интернет-провайдер в конце 90-х**, когда сервера стали недоступны из-за лавины SYN-запросов, якобы приходящих от тысяч клиентов, но на самом деле с поддельными IP-адресами.

Эта атака стала толчком к разработке методов защиты, включая **SYN cookies** — способ откладывать выделение ресурсов до получения финального ACK-пакета.

## **1. XDP — идеальный пред-фильтр**

XDP работает на уровне драйвера, поэтому:

- может **молниеносно отбрасывать ненужные пакеты** (например, SYN-флуд),
    
- **снижает нагрузку** на остальной стек (не идёт дальше ни в netfilter, ни в TCP/IP, ни в userspace),
    
- идеально подходит для DDoS mitigation, whitelist/blacklist IP, блокировки протоколов по заголовкам и т.п.
    

---

## **2. Что значит "фильтр без RST"?**

Когда выполняется условие:

```c
if (tcph->syn && !tcph->ack) return XDP_DROP;
```

Происходит следующий сценарий:

- Хост-получатель ничего не отвечает (пакет уничтожен),
- Удалённый клиент **не получает ни SYN-ACK, ни RST**,
- Он будет **ретрансмитить SYN** до таймаута,
- TCP-клиент **в итоге сам откажется от соединения** (по таймеру),
- При этом получатель
- сэкономил ресурсы.

---

## **3. Когда это уместно?**

XDP-фильтр без ответа (RST) хорошо работает, когда:

- **Тебе важна скорость**, а не "вежливость",
    
- **Ты хочешь игнорировать злоумышленников**, не говоря им, что ты существуешь (stealth mode),
    
- **Ты отбиваешь сканеры**, которые ищут открытые порты,
    
- **Ты защищаешь внутренние сервисы**, которые не должны быть видны наружу.
    

---

## **4. Какой фильтр ты хочешь построить?**

Вот идеи:

|Цель|Как использовать XDP|
|---|---|
|Блокировать SYN|`if (syn && !ack) return XDP_DROP;`|
|Блокировать по IP|Проверка `iph->saddr` или `daddr`|
|Пропускать только whitelist IP|Сравнение с eBPF map|
|Блокировать всё, кроме 443 порта|Проверка `tcph->dest == htons(443)`|
|Логировать подозрительные IP|Использовать perf event или eBPF map счётчики|

---

## **5. А если RST всё-таки нужен...**

Тогда делай двухуровневую архитектуру:

- **XDP** — для грубой фильтрации (очевидный мусор — в дроп),
    
- **TC (clsact/ingress)** — для генерации TCP RST и более умных реакций.