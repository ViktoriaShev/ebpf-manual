# eBPF technology. Creation of xdp filter

## Введение. Подготовка необходимых пакетов

eBPF — это революционная технология, берущая начало в ядре Linux, которая позволяет запускать изолированные программы в привилегированном контексте, например, в ядре операционной системы. Она используется для безопасного и эффективного расширения возможностей ядра без необходимости изменять исходный код ядра или загружать модули ядра.

Проверка установленных возможностей eBPF: 
```
uname -r  # проверяем версию ядра, минимальная версия Linux 4.4
bpftool feature probe  # проверяем поддержку eBPF в ядре
```

Чтобы писать код используя eBPF на OC Linux, необходимы следующие программные пакеты: 

### Компиляторы и инструменты сборки:
- clang — компилятор, поддерживающий генерацию кода для eBPF. 
- llvm — набор инструментов для компиляции, необходимый для clang. 
- gcc-multilib — поддержка 32-битных библиотек, если требуется. 
### Библиотеки и заголовочные файлы:

- libelf-dev — библиотека для работы с ELF-файлами, необходима для загрузки eBPF-программ. 
- libbpf-dev — библиотека BPF, которая помогает загружать и управлять eBPF-программами. 
- linux-headers-$(uname -r) — заголовочные файлы ядра, необходимые для сборки. 

### Инструменты eBPF: 

bpftool — утилита для работы с eBPF-программами в ядре (загрузка, отладка, просмотр карт и т.д.).\
linux-tools-$(uname -r) — набор инструментов для работы с ядром, включая perf (может быть полезен для профилирования eBPF-кода).

Загрузить все можно в терминале этой командой: 
```
sudo apt install -y clang llvm libelf-dev libbpf-dev gcc-multilib linux-headers-$(uname -r) bpftool
```

### Фреймворк eunomia-bpf(ecli) в связке с ecc: 
Также хочется отметить фреймворк eunomia-bpf.
Исходный код на C (my_program.c) компилируется в .wasm с помощью ecc:
```
ecc build my_program.c -o my_program.wasm
```
Также создается .json-файл с метаданными eBPF-программы.

После компиляции можно запустить eBPF-программу с помощью ecli:
```
ecli run my_program.json
```
ecli прочитает .json, загрузит .wasm и выполнит eBPF-программу.

*ссылка на гит: https://github.com/eunomia-bpf/libbpf-starter-template?tab=readme-ov-file* 

## Описание программы "xdp_filter"

Ниже приведено объяснение ключевых особенностей кода eBPF-программы для XDP (eXpress Data Path), которая фильтрует пакеты на основе IP-адреса и порта.
- Заголовок лицензии
 
/* SPDX-License-Identifier: (LGPL-2.1 OR BSD-2-Clause) */ \
Указывает, что код лицензируется под LGPL-2.1 или BSD-2-Clause.\
Позволяет использовать этот код в проектах с разными типами лицензий.

- Отключение глобальных данных 
```
#define BPF_NO_GLOBAL_DATA
```
Запрещает использование глобальных переменных в eBPF-коде.\
Это ограничение связано с eBPF-архитектурой: глобальные данные не поддерживаются в XDP-программах.

- Подключение заголовочных файлов

#include <linux/bpf.h>           // Основные eBPF API \
#include <bpf/bpf_helpers.h>     // Вспомогательные макросы и функции 

- Определение структур

Для реализации поставленной задачи была определена структура "filter, которая оределяет тип для ip и post. Для таких сетевых параметров обычно используется big-endian 32/16 bits тип хранения.\
Map — это структура данных, к которой можно получить доступ из программы eBPF и из пространства пользователя. Карты можно использовать для обмена данными между несколькими программами eBPF или для связи между приложением пространства пользователя и кодом eBPF, работающим в ядре.
Инициализируем eBPF map "filter_map", которая будет хранить в key структуру filter с данными ip и port. Тип данной map - BPF_MAP_TYPE_HASH.\
Карты на основе BTF должны быть размещены в разделе(SEC) ".maps".
```
struct {
    __uint(type, BPF_MAP_TYPE_HASH);   // Тип карты: хэш-таблица
    __uint(max_entries, 1024);         // Максимальное количество записей
    __type(key, struct filter);        // Ключ — структура filter (IP + порт)
    __type(value, int);                // Значение — просто число (обычно 1)
} filter_map SEC(".maps");

```
- Объявление xdp программы 
```
SEC("xdp")
int filter_packets(struct xdp_md *ctx) {
```

SEC("xdp") — макрос, объявляющий XDP-программу.\
Название раздела часто имеет неявное значение и может изменить то, как загрузчик (библиотека), такой как libbpf, будет интерпретировать содержимое этого раздела.
Все программы в разделе xdp будут загружены как программы типа BPF_PROG_TYPE_XDP и присоединенного типа BPF_XDP, в xdp.frags также будет установлен флаг BPF_F_XDP_HAS_FRAGS.

Программа XDP вызывается ядром с контекстом xdp_md. Возвращаемое значение указывает, какое действие ядро ​​должно выполнить с пакетом, разрешены следующие значения:

- XDP_DROP — отбрасывает пакет. Следует отметить, что поскольку мы отбрасываем пакет очень рано, он будет невидим для таких инструментов, как tcpdump.
- XDP_PASS — передает пакет в сетевой стек. Пакетом можно манипулировать заранее

struct xdp_md *ctx — структура, содержащая данные о сетевом пакете.\
Обычно структура выглядит примерно так:
```
struct xdp_md {
    __aligned_u64 data;         // Указатель на начало данных пакета
    __aligned_u64 data_end;     // Указатель на конец данных пакета
    __aligned_u64 data_meta;    // Дополнительный указатель для метаданных
    __u32 rx_queue_index;       // Индекс очереди для XDP
};

```
- Получение указателей на данные пакета
```
void *data = (void *)(long)ctx->data;
void *data_end = (void *)(long)ctx->data_end;
```
ctx->data — начало пакета.\
ctx->data_end — конец пакета.

Нельзя обращаться к памяти за data_end (иначе программа завершится с ошибкой).\
Проверяем, что он полностью помещается в пакете (если нет — пропускаем пакет).

 -Обработка Ethernet-заголовка
 
 Cтруктура ethhdr состоит из 14 байт:
```
struct ethhdr *eth = data;

if ((void *)(eth + 1) > data_end) return XDP_PASS;
struct ethhdr *eth = data; //Мы начинаем обработку с Ethernet-заголовка.
```
Эта строка проверяет, является ли протокол Ethernet IP. \
ETH_P_IP — это значение, которое соответствует протоколу IP. \
Если протокол не IP, то пакет пропускается с помощью XDP_PASS.
```
if (eth->h_proto != __constant_htons(ETH_P_IP)) return XDP_PASS;
```

- Обработка IP-заголовка:
```
struct iphdr *ip = (void *)(eth + 1);
```
После Ethernet-заголовка начинается IP-заголовок. Мы вычисляем его адрес, прибавив размер Ethernet-заголовка (это eth + 1).

- Создание ключа (IP + порт)
```
struct filter key = {};
key.ip = ip->saddr;
```
Заполняем структуру key — записываем IP-адрес отправителя.

- Определение порта (TCP или ICMP)

Если TCP → извлекаем порт назначения (tcp->dest).
Если ICMP → устанавливаем key.port = 0 (ICMP не использует порты).
Все остальные протоколы пропускаем (XDP_PASS).

- Проверка, нужно ли блокировать пакет
```
int *value = bpf_map_lookup_elem(&filter_map, &key);
bpf_printk("%d\n", value);
if (value != NULL) {
    bpf_printk("Blocked packet: dest_ip=%x, dest_port=%d\n", key.ip, key.port);
    return XDP_DROP;
}
```

bpf_map_lookup_elem(&filter_map, &key) ищет key (IP + порт) в filter_map.

```
static void *(* const bpf_map_lookup_elem)(void *map, const void *key) = (void *) 1;
```

Аргумент карты должен быть указателем на определение карты, а ключ должен быть указателем на ключ, который вы хотите найти.\
Возвращаемое значение будет указателем на значение карты или NULL. Значение является прямой ссылкой на память ядра, где хранится это значение карты, а не копией.\
Если запись найдена → блокируем пакет (XDP_DROP).
Если нет → пропускаем (XDP_PASS).

- Указание лицензии
```
char LICENSE[] SEC("license") = "Dual BSD/GPL";
```
eBPF-программы должны указывать лицензию. "Dual BSD/GPL" позволяет использовать код как с BSD, так и с GPL.

### Принцип работы программы

Если пакет соответствует правилам фильтрации (которые хранятся в eBPF-карте filter_map), он отбрасывается (XDP_DROP).
В остальных случаях — пропускается (XDP_PASS).

## Описание программы "program_user"

### Подключение библиотек 
 arpa/inet.h — работа с сетевыми адресами (inet_pton для преобразования IP).\
 bpf/libbpf.h, linux/bpf.h, bpf/bpf.h — заголовки для взаимодействия с eBPF-картами.\
 linux/if_ether.h, linux/if_packet.h — сетевые протоколы (Ethernet, IP).\
 unistd.h, sys/stat.h — системные вызовы (close, fstat).

### Определение пути к eBPF-карте
```
#define BPF_MAP_PATH "/sys/fs/bpf/filter_map"
```
Путь к BPF-карте, созданной XDP-программой и закрепленной (pinned) в файловой системе.

- Определение структуры для ключа карты
Ключ (key) eBPF-карты состоит из: __be32 ip — IP-адрес (4 байта, big-endian). __be16 port — Порт (2 байта, big-endian).

- Функция добавления записи в карту
Функция bpf_obj_get() используется для открытия eBPF-карты (или другого eBPF-объекта), который был закреплен (pinned) в файловой системе BPF.
Прототип функции
```
int bpf_obj_get(const char *pathname);
```
Аргумент:\
pathname — путь к eBPF-объекту в файловой системе BPF (/sys/fs/bpf/...).\
Если успешно, возвращает файловый дескриптор (FD) eBPF-объекта (неотрицательное число).
```
void add_entry(const char *ip, const char *port) {
    int map_fd = bpf_obj_get(BPF_MAP_PATH);  // Открытие BPF-карты
    if (map_fd < 0) {
        perror("Failed to open BPF map");
        return;
    }
bpf_obj_get(BPF_MAP_PATH) — открывает карту BPF по пути.
```

- Далее идет заполнение ключа:
inet_pton(AF_INET, ip, &key.ip) — преобразует строку IP в число (big-endian). \
htons(atoi(port)) — преобразует порт в big-endian.\

- Функция bpf_map_update_elem()
Прототип
```
int bpf_map_update_elem(int fd, const void *key, const void *value, __u64 flags);
```
Функция используется для добавления или обновления элемента в eBPF-карте.

Аргументы:\
int fd -Файловый дескриптор (FD) eBPF-карты, полученный через bpf_obj_get().\
const void *key -Указатель на ключ, по которому будет обновляться или добавляться элемент в карту.\
const void *value -Указатель на значение, которое нужно добавить в карту.\
__u64 flags -Определяет поведение при обновлении элемента.

Возможные значения:

BPF_ANY (0) → Добавить или обновить существующую запись.\
BPF_NOEXIST (1) → Добавить только если ключа еще нет.\
BPF_EXIST (2) → Обновить только если ключ уже существует.\

Возвращаемое значение:

0 → Успех (элемент добавлен или обновлен).\
-1 → Ошибка (например, неверный fd, размер ключа, карта заполнена).

```
    int value = 1;
    printf("Adding entry: IP=%x, Port=%x\n", ntohl(key.ip), ntohs(key.port));

    if (bpf_map_update_elem(map_fd, &key, &value, BPF_ANY) < 0) {
        perror("Failed to add entry");
    } else {
        printf("Added: %s:%s\n", ip, port);
    }
```

### Функция удаление записи
- Функция bpf_obj_get() для открытия eBPF-карты
```
void del_entry(const char *ip, const char *port) {
    int map_fd = bpf_obj_get(BPF_MAP_PATH);
    if (map_fd < 0) {
        perror("Failed to open BPF map");
        return;
    }
bpf_obj_get() открывает карту.
```
- Преобразование IP и порта аналогично add_entry().
```
    struct filter key = {};
    if (inet_pton(AF_INET, ip, &key.ip) != 1) {
        perror("Invalid IP address");
        close(map_fd);
        return;
    }
    key.port = htons(atoi(port));
```
- Функция bpf_map_delete_elem(map_fd, &key)

Прототип:
```
int bpf_map_delete_elem(int fd, const void *key);
```
Эта функция удаляет элемент из eBPF-карты по заданному ключу.\

Аргументы:\
int fd -Файловый дескриптор (FD) eBPF-карты, полученный через bpf_obj_get().\
const void *key -Указатель на ключ, по которому нужно удалить элемент из карты.

Возвращаемое значение:\
0 → Успех (элемент успешно удален).\
-1 → Ошибка (например, ключ не найден или неверный fd).
```
    if (bpf_map_delete_elem(map_fd, &key) < 0) {
        perror("Failed to delete entry");
    } else {
        printf("Deleted: %s:%s\n", ip, port);
    }
    close(map_fd);
```

### Вывод содержимого карты
Создается массив cmd размером 128 байт.
В этот массив будет записана строка системной команды, которую затем выполнит system().
```
snprintf(cmd, sizeof(cmd), "bpftool map dump pinned %s", BPF_MAP_PATH);
```
snprintf() записывает строку в cmd, подставляя BPF_MAP_PATH (путь к eBPF-карте).

Итоговая строка:

bpftool map dump pinned /sys/fs/bpf/filter_map 

``` system(cmd) ```  выполняет команду в терминале.
Эта команда показывает содержимое карты.

По сути, это аналог ввода команды вручную:
```
bpftool map dump pinned /sys/fs/bpf/filter_map
```
bpftool выводит список всех записей в BPF-карте.

pinned /sys/fs/bpf/filter_map → Использует прикрепленный (pinned) путь к карте filter_map.
```
void list_entries() {
    char cmd[128];
    snprintf(cmd, sizeof(cmd), "bpftool map dump pinned %s", BPF_MAP_PATH);
    system(cmd);
}
```

### Функция main()

Функция main() выполняет разбор аргументов командной строки и вызывает соответствующие функции для управления eBPF-картой. \

Общий алгоритм работы\
Проверка аргументов: если аргументов меньше 2, выводит подсказку по использованию.\

- Если команда "add" и переданы IP + порт, вызывает add_entry(). Вызов add_entry(ip, port) 
- Если команда "del" и переданы IP + порт, вызывает del_entry(). Вызов del_entry(ip, port)
- Если команда "list", вызывает list_entries(). Вызов list_entries()
- В противном случае сообщает об ошибке ввода.

Если всё прошло успешно, возвращает 0.

### Принцип работы программы

Она действует как обработчик команд, позволяя пользователю:\
add Добавлять IP и порт в BPF-карту.\
add Удалять IP и порт из BPF-карты.\
list Просматривать содержимое карты.

Cинтаксис команды:\
sudo ./program_user command ip port

Пример:
```
sudo ./program_user add 1.1.1.1 1
```
## Компиляция и загрузка в ядро:
Ниже представлены необходимые и дающие дополнительную информацию комманды:\

Эта команда компилирует исходный код eBPF (xdp_filter.bpf.c) в объектный файл (xdp_filter.o), который затем загружается в ядро Linux.

- O2 (Оптимизация уровня 2)
Средний уровень оптимизации, который:\
Удаляет избыточный код.\
Улучшает использование регистров.\
Минимизирует ветвления.

- target bpf - указывает, что код должен быть скомпилирован не для x86/ARM, а для BPF-виртуальной машины.\
Генерирует байткод, который выполняется внутри ядра Linux.\
- g (Отладочная информация) Включает отладочную информацию в формате DWARF.

- c (Только компиляция, без линковки)
Преобразует xdp_filter.bpf.c в объектный файл xdp_filter.o без создания исполняемого файла.\
Линковка в eBPF не требуется, так как объектный файл загружается прямо в ядро.\

```
clang -O2 -target bpf -g -c xdp_filter.bpf.c -o xdp_filter.o
```
2️⃣ Загрузка eBPF в XDP (на нужный интерфейс, например, eth0):
Эта команда загружает eBPF-программу (из файла xdp_filter.o) в сетевой интерфейс (enp0s3) с использованием XDP (eXpress Data Path).\
ip link -Утилита ip управляет сетевыми интерфейсами в Linux. Подкоманда link отвечает за изменение параметров интерфейсов.\
set dev enp0s3 set dev — команда для изменения параметров указанного интерфейса.\
enp0s3 — имя сетевого интерфейса (может быть eth0, wlp2s0 и т. д.).
xdp obj xdp_filter.o xdp — указывает, что загружается eBPF-программа для XDP.
sec xdp -sec (section) — указывает секцию в eBPF-программе, которую нужно загрузить.

Принцип работы:
- Открывает eBPF-объектный файл xdp_filter.o.
- Ищет секцию xdp в xdp_filter.o.
- Загружает eBPF-программу в XDP-систему ядра.
- Привязывает eBPF-фильтр к сетевому интерфейсу enp0s3.
- Начинает обработку входящих пакетов через XDP, работая на уровне драйвера сетевой карты.
```
ip link set dev enp0s3 xdp obj xdp_filter.o sec xdp
```
3️⃣ Монтирование BPF-файловой системы (если еще не сделано):
```
mount -t bpf bpf /sys/fs/bpf
```
4️⃣ Закрепление eBPF-карты:
Закрепление(pin) в файловой системе означает, что есть дополнительная ссылка на
карту (map), поэтому map остается загруженной после завершения команды.
```
bpftool map pin name filter_map /sys/fs/bpf/filter_map
```
5️⃣ Компиляция пользовательской программы, работающей с eBPF:
```
gcc -o program_user program_user.c -lbpf
```
6️⃣ (Отладка) Просмотр трассировки eBPF-программы:
```
sudo cat /sys/kernel/debug/tracing/trace_pipe
```
7️⃣ (Отладка) Просмотр сообщений ядра:
```
sudo dmesg -w
```
8️⃣ (Отключение) Если нужно отключить eBPF-программу:

Удаление программы XDP с помощью ip link можно выполнить следующим образом:
```
sudo ip link set dev eth0 xdp off
```
9️⃣ (Диагностика) Проверка статистики XDP:
```
ethtool -S enp0s3 | grep xdp
```

## Как проверить работу фильтра
Сначала следует добавить в filter_map запрещенные адреса и порты:\
Для этого есть команда "add" и "del"

```
sudo ./program_user add 192.168.177.120 80
sudo ./program_user add 8.8.8.8 0
```
Добавили в blacklist source ip адрес 192.168.177.120 с портом 80 и 8.8.8.8 с портом 0.\

Проверить работу фильтра можно несколькими способами:\

1. ping
   
```
ping 8.8.8.8
```

В /sys/kernel/debug/tracing/trace_pipe будут динапически выводится отлавливаемые пакеты. При блокировке будет выведена такая строка:\ 

```
 ksoftirqd/0-16      [000] ..s11   555.294665: bpf_trace_printk: Blocked packet: source_ip=8080808, source_port=0
```

2. утилита hping3
```
 sudo hping3 --spoof 192.168.177.120 -s 80 -p 80 -S 10.0.2.15
```
В /sys/kernel/debug/tracing/trace_pipe при блокировке будет выведена такая строка:
```
<idle>-0       [000] .Ns21   693.769283: bpf_trace_printk: Blocked packet: source_ip=78b1a8c0, source_port=20480
```

## Теория ebpf работы программы  
### Закрепление
Загрузка программы BPF в ядро ​​с помощью системного вызова bpf() возвращает
файловый дескриптор. В ядре этот файловый дескриптор является ссылкой на программу.
Процесс пользовательского пространства, который сделал системный вызов, владеет этим файловым дескриптором; когда этот процесс
завершается, файловый дескриптор освобождается, а счетчик ссылок на программу
уменьшается. Когда не остается ссылок на программу BPF, ядро
удаляет программу.

Дополнительная ссылка создается, когда вы закрепляете программу в файловой системе.
Закрепление ее в файловой системе означает, что есть дополнительная ссылка на
программу, поэтому программа остается загруженной после завершения команды.
Счетчик ссылок также увеличивается, когда программа BPF присоединена к
хуку, который ее вызовет. Поведение этих счетчиков ссылок зависит от типа программы BPF. Eсть
некоторые типы, которые относятся к трассировке (например, kprobes и tracepoints) и всегда связаны с процессом пользовательского пространства; для этих типов программ eBPF счетчик ссылок ядра уменьшается при завершении этого процесса. Программы, которые прикреплены
внутри сетевого стека или cgroups (сокращение от «контрольные группы»), не связаны
ни с каким процессом пользовательского пространства, поэтому они остаются на месте даже после завершения работы программы пользовательского пространства,
которая их загружает. Загрузка программы XDP с помощью команды ip link:
```
ip link set dev enp0s3 xdp obj xdp_filter.o sec xdp
```

Команда ip завершена, и нет определения закрепленного местоположения, но
тем не менее, bpftool покажет вам, что программа XDP загружена в ядро:
```
$ bpftool prog list
```
Счетчик ссылок для этой программы не равен нулю из-за присоединения к хуку XDP, которое сохранилось после завершения команды ip link.
Карты eBPF также имеют счетчики ссылок, и они очищаются, когда их счетчик ссылок падает до нуля. Каждая программа eBPF, которая использует карту, увеличивает счетчик, как и каждый файловый дескриптор, который программы пользовательского пространства могут хранить для карты.
Возможно, исходный код программы eBPF может определять карту, на которую программа на самом деле не ссылается. Если программа eBPF ничего не делает с картой, автоматически не будет счетчика ссылок из программы на карту. Существует системный вызов BPF(BPF_PROG_BIND_MAP), который связывает карту с программой, так что карта не очищается, как только программа-загрузчик пользовательского пространства завершает работу и больше не хранит ссылку на дескриптор файла для карты.
Карты также могут быть закреплены в файловой системе, и программы пользовательского пространства могут получить доступ к
карте, зная путь к карте.

### Трассировки 
Точки трассировки — это метод статического инструментирования ядра, технически просто функции трассировки, размещенные в исходном коде ядра, которые по сути являются точками зондирования с контрольными условиями, вставленными в исходный код, что позволяет выполнять постобработку с дополнительными функциями обработки. Например, наиболее распространенным методом статической трассировки в ядре является printk, который выводит сообщения журнала. Например, существуют точки трассировки в начале и конце системных вызовов, событий планировщика, операций файловой системы и дискового ввода-вывода. Точки трассировки были впервые представлены в Linux версии 2.6.32 в 2009 году. Точки трассировки — это стабильный API, и их количество ограничено.
Можно увидеть доступный набор подсистем трассировки в ядре, просмотрев /sys/
kernel/tracing/available_events

## Использованные источники:
- "Learning eBPF: Programming the Linux Kernel for Enhanced Observability, Networking, and Security." Publisher: O'Reilly Media
- github.com/eunomia-bpf/bpf-developer-tutorial/tree/main/
- https://docs.ebpf.io/linux/ - официальная документация 
